#!/usr/bin/env python

import rospy
from sensor_msgs.msg import FluidPressure
from bluerov_sim.msg import ActuatorCommands


class ControlNode():
    def __init__(self,name):
        rospy.init_node(name)

        self.controller = Controller()
        self.t_last = rospy.get_time()
    
        self.vertical_thrust = 0.0
        self.depth_setpoint = -0.5

        self.actuator_pub = rospy.Publisher("bluerov/mixer/actuator_commands",
                                            ActuatorCommands,
                                            queue_size=1)

        self.pressure_sub = rospy.Subscriber("pressure",
                                             FluidPressure,
                                             self.on_pressure,
                                             queue_size=1)
    
    def on_pressure(self, msg):
        water_pressure = msg.fluid_pressure
        air_pressure = 101325     
        pascal_per_meter = 0.0981e5
        
        depth = -(water_pressure - air_pressure)/pascal_per_meter
        
        error = depth - self.depth_setpoint
        now = msg.header.stamp.to_sec()

    #    update_controller(error=error, now=now)

    #def update_controller(self, error, now):
        
        dt = now - self.t_last
        self.t_last = now

        u = self.controller.update(error=error, dt=dt)

        self.vertical_thrust = -u
        rospy.loginfo(u)
    
    def publish_message(self):
        msg = ActuatorCommands()
        
        msg.header.stamp = rospy.Time.now()
        msg.vertical_thrust = self.vertical_thrust
        
        self.actuator_pub.publish(msg)
    
    def run(self):
        rate = rospy.Rate(30.0)

        while not rospy.is_shutdown():

            self.publish_message()

            rate.sleep()

class Controller():
    def __init__(self, p_gain=2.0, i_gain=0.0, d_gain=0.0):
        self.p_gain = p_gain
        self.i_gain = i_gain
        self.d_gain = d_gain
        
        self.e = 0.0
        self.u = 0.0

        self._error = 0.0
        self._integral = 0.0
        self._derivative = 0.0
        self._last_error = 0.0
    
    def update(self, error, dt):
        self._error = error
        self._update_integral(error, dt)
        self._update_derivative(error, dt)

        self.u = error * self.p_gain + self._integral * self.i_gain + self._derivative * self.d_gain
        
        return self.u

    def _update_integral(self, error, dt):
        delta_integral = dt * error
        self._integral = self._integral + delta_integral
    
    def _update_derivative(self, error, dt):
        self._derivative = (error - self._last_error) / dt


def main():
    node = ControlNode("depth_controller")
    node.run()


if __name__ == "__main__":
    main()